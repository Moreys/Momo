# 数据结构与算法之美（极客时间）

## 02|如何抓住重点，系统高效的学习书籍结构与算法

### 技巧

- 边学边练，适度刷题
  - 集中时间攻克某个算法，必须自己用代码实现一遍
  - 适度刷题，不要浪费太多时间
  - 
- 多问，多思考，多互动
  - 找几个人一起学习，一块讨论切磋，有问题及时提问老师
- 打怪升级学习法
  - 一关一关来，保持学习的情趣，坚持下去，自己设计目标，攻克每个目标
- 知识需要沉淀，不要试图一下子掌握所有知识
  - 学习知识的过程是反复迭代，不管积累的过程



## 03|复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗

### 大O复杂度表示法

- cpu面对代码——读数据——运算——写数据
- **所有代码的执行时间T(n)与每行代码的执行次数n成正比**
- ```T(n) = O(f(n))```
- 表达的是：代码执行时间随数据规模增长的变化趋势，也叫渐进时间复杂度（asymptotic  time complexity）简称**时间复杂度**

### 时间复杂度

- 只关注循环执行次数最多的一段代码
- 分析一个算法，一段代码的时间复杂度的时候，也只关注循环次数最多的一段代码就可以了
- 加法法则：总复杂度等于量级最大的那段代码的复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### 常见多项式算法复杂度分析

- O(1)：只要算法中不存在循环语句、递归语句，其时间复杂度都为O(1)。
- O(logn)、O(nlog)：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n）） = O(f(n))
- O(m+n)、O(m*n)：有两个数据规模决定，如两个分开的for循环



### 空间复杂度

- 渐进空间复杂度（asymptotic  space complexity）：表示算法的存储空间与数据规模之间的递增长关系

- 

## 04、复杂度分析（下）：浅析最好、最坏、评论、均摊时间复杂度

- 最好情况时间复杂度（best case  time complexity）
- 最坏情况时间复杂度（worst case time complexity)
- 平均情况时间复杂度（average case time complexity）
- 均摊时间复杂度（amortized  time complexity）

### 1、最好、最坏情况复杂度

- 最好：在最理想的情况下，执行这段代码的时间复杂度
- 最坏：在最糟糕的情况下，执行这段代码的时间复杂度



### 2、平均情况时间复杂度

- 加权平均时间复杂度或者期望时间复杂度。

### 3、均摊时间复杂度

- 摊还分析法，：得到的时间复杂度我们起了一个名字，叫：**均摊时间复杂度**
- 每一次O(n)的插入操作都会跟着n-1次O(1)的插入操作，所有把耗时多的那次操作均摊到接下来的n - 1次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是O（1）
- 均摊时间复杂度是一种特殊的平均时间复杂度。
- 其实可以简单的理解为：把时间多的分配给时间少的，得到一个中间值，



## 5、数组：为什么很多编程语言中数组都是从0开始编号

### 1、实现随机访问

- 数组（Array）：是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。

- 线性表（Linear List）：数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向

  - 线性结构分类主要有：数组、链表、队列、栈

  - 非线性结构分类：树、堆、图

- 连续的内存空间和相同类型的数据——随机访问贼快

- 链表适合插入、删除，时间复杂度O(1)；数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。

### 2、低效的“插入”和“删除”

- 插入：需要移动后面的元素
- 删除：删除以后为了保证连续性，也需要进行数据的移动
- 提高效率：如果要删除数据为前面的，可以先标记为删除，到数组没有空间的时候再触发删除操作
- 很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧。

### 3、警惕数组的访问越界问题

- 访问数组的本质是：访问一段连续的内存空间。
- 有些语言会有提醒机制来提醒程序员某个数组访问越界的问题

### 3、容器和数组的比较

- 容器：将很多数组操作的细节封装起来。而且支持动态扩容
- 扩容注意事项：扩容的时候涉及——内存申请和数据迁移，比较耗时，所有在创建容器的时候最好先确定数据大小
- 两者开发选择对比：
  - 容器语法存储基本类型，有时候需要进一步封装，会消耗性能
  - 如果数据事先已知，并且对数据点 操作非常简单，用不到容器提供的一些功能，可以直接使用数组
  - 总结：对于业务开发，直接使用容器就足够了，省时省力。性能消耗也不会很大，但是如果开发底层的，比如网络框架、性能的优化需要做到极致则优先使用数组

## 06、链表（上）：如何实现LRU缓存淘汰算法

- 缓存淘汰的三种情况：
  - 先进县出策略FIFO（first IN，First Oot）
  - 最少使用策略LFU（Least Frequently  Used）
  - 最近最少使用策略LRU（Least Recently Used）

### 1、链表和数组的比较

- 数组：连续的内存空间：分配的时候如果空间不够大则分配失败
- 链表：通过“指针”将一组零散的内存块串联起来使用、

### 2、链表分类

- 链表分类：单链表、双向链表、循环链表

- 单链表的组成：内存块称为链表的节点：除了每个节点记录数据以外，还需要一个指向下一个节点的指针域

- 两个特殊位置：头结点、尾结点

- 循环链表：特殊的单链表（尾巴指向头）

- 双向链表：两个指针（一个指前一个节点，一个指向后一个节点）一个数据，

- 链表的删除操作：

  - 删除节点中“等于某个给定值”的节点
    - 不管双向还是单向，查找值的时候都必须遍历一次链表。然后找到值，再进行删除
  - 删除给定指针指向的节点
    - 即使知道了要删除的点，但是根据删除原则，不知道前驱，所有还是需要遍历才知道前驱

- 空间换时间：执行较慢的程序，可以通过消耗更多内存

- 时间换空间：消耗过多内存的程序，可以通过消耗更多的时间

- 二则对比

  - 数组：连续内存空间：可以借助CPU缓存机制，预读数组，访问效率高。大小固定，而且内存要先分配。即使有些语言的容器支持动态扩容，但是也是通过拷贝数据来实现的，时机运行的时候还是非常耗时的

  - 链表：内存中不连续，对CPU缓存不友好。没办法有效预读取；没有空间限制，可以动态扩容

- 对内存使用苛刻的数组更适合，链表的额外消耗的内存是数组的两倍，而且对链表进行平凡的插入、删除会导致内存申请和释放，容易造成内存碎片，有些高级语言会频繁的触发GC（如C#、和Java）

### LRU缓存算法（最近最少使用）

- 描述：维护一个有序单链表，越靠近链表尾部的节点越早之前访问的，当一个新的数组被访问时，我们从**链表头开始顺序遍历**
  - 如果此数据之前已经缓存在链表中了，我们遍历得到这个数组对应的节点，并将其从原来的位置删除，然后再插入到链表头部。
  - 如果此数据没有缓存链表中，又分为两种情况
    - 缓存未满：将数据插入到链表头部
    - 缓存已满：链表尾节点删除，新的数据节点插入链表头部。
- 优化：使用散列表（Hash table）
- 数组实现：
  - 
- 用链表判断是不是回文字符（链表存储）
  - 遍历链表，奇数是，偶数不是



## 07、链表（下）：如何轻松写出正确的链表代码

### 1、技巧一：理解指针或引用的含义

- 指针：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，指向那个变量，就把变量的值赋值给指针，要和内存配合来理解
- p->next = q：p节点中的next指针存储了q节点的内存地址，实际上，p就是结构体，next就是结构体中的一个结构体指针。

### 2、技巧二：警惕指针丢失和内存泄漏

- 插入节点的时候一定要注意操作的顺序，新节点记录要插入位置后面的节点，要插入位置前面的节点在记录新节点
- 删除链表节点时，一定要记得手动释放内存空间。

### 3、技巧三：利用哨兵简化实现难度

- 针对链表的插入、删除、需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。



### 4、技巧四：重点留意边界处理

- 代码写完检查一下条件下是否运行成功：
  - 链表为空
  - 链表只有一个节点
  - 链表只有两个节点
  - 代码逻辑在处理头节点和尾节点的时候。



#### 5、技巧五：举例画图，辅助思考

- 通过画图和举例的当时来简化思维，按图来编写代码

### 6、技巧六：多写多练，没有捷径

- 五中常见操作
  - 单链表反转
  - 链表中环的检查
  - 两个有序链表合并
  - 删除链表倒数第n个节点
  - 求链表中节点

### 7、总结

- 写链表代码是最考验逻辑思维能力的。
- 写的好坏考验一个人的细心，考虑问题是否全面，思维是否缜密

### 8、课后思考——哨兵的其他应用

- 简化边界处理





## 09、队列：队列在线程池等有限资源池中的应用

### 如何理解队列

- 先进者先出，入队push() 放一个数据到队列尾部。出队dequeue()从队列头部取一个元素
- 队列也是一种操作受限的线性表数据结构



### 2、顺序队列和链式队列

- 顺序队列：用数组实现的队列
- 链式队列：用链表实现的队列
- 实现分析
  - 需要一个头指针和一个尾指针，指向队头和队尾
  - 
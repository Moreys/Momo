C++Primer笔记



# C++Primer笔记

## 第一章、开始

## 1.5 类的介绍

### 1.5.1

### 1.5.2初始成员

- 函数成员——定义为类的一部分的函数，有时也被称为方法（method）

### 术语表

- 参数（实参，argument）向函数传递的值。
- 赋值（assignment）抹去一个对象的当前值，用一个新值取代之
- 程序块（block）零条或多条语句的序列，用花括号包围
- 缓冲区（buffer）一个存储区域，用于保存数据。IO设施通常将输入（或输出）数据保存在一个缓冲区中，读写缓冲区的动作与程序中的动作是无关的，我们可以显示的刷新输出缓冲，以便强制缓冲区中的数据写入输出设备，默认情况下，读cin会刷新count，程序非正常终止也会刷新cout。
- 内置类型（built-in type）由语言定义的类型 如int。
- Cerr 一个ostream对象，关联到标准错误，通常写入到标准输出相同的设备，默认情况， 写到cerr的数据不是缓冲的，cerr通常用于输出错误信息或其他不属于程序正常逻辑的输出内容。
- 字符串字面常量（character string literal）string literal 的另一种叫发。
- cin  一个isteream对象，用来从标准输入读取数据
- 类（class）一种用于定义自己的数据结构一起相关操作的机制，类是C++中最基本的特性之一，标准库类中，如istream和ostream都是类。
- 类类型（class type）类定义的类型，类名即为类型名
- clog 一个ostream对象，关联到标准错误，默认情况下，写到clog的数据是被缓冲的，clog通常用于报告程序的执行信息，存入一个日志文件中。
- 条件（condition）求值结果为真或假的表达式，通常用值0表示假，非零表示真。
- cout 一个ostream对象，用于将数据写入标准输出。通常用于程序的正常输出内容
- 数据结构（data structure）数据机器上锁允许的操作的一种逻辑组合
- 文件结束符（end-of-file）系统特定的标识，指出文件中更多数据了。
- 表达式（expression）最小的计算单元，一个表达式包含一个或多个运算符对象，通常还包含一个或多个运算符，表达式值会参数一个结果，例如，假设i和j是int对象，则i+j是一个表达式，她产生两个int值的和。
- 形参列表（parameter list）函数定义的一部分，指出调用函数时可以使用寿命样的实参，可能为空列表
- 函数（function）具名的计算单元
- 返回类型（return type）函数返回值的类型
- 函数体（function body）语句块，定义函数所执行的动作。
- 源文件（source file）包含C++程序的文件。
- 函数名（function name）函数为人所知的名字，也用来进行函数调用。
- 标准错误（standard error）输出流，用于报告错误，标准输出和标准错误通常关联到程序执行所在窗口相关联
- 头文件（header）使类或其他名字的定义可被多个程序使用的一种机制，程序通过#include指令使用头文件
- if语句（if statement）根据一个特定条件的值进行条件执行的语句，如果条件为真，执行if语句体，否则执行else语句体（如果存在的话）
- 初始化（initialize）在一个对象创建的时候，赋予它一个值。
- iostream提供了面向流的输入的库类型
- 库类型（library type）标准库定义的类型 如istream
- main 操作系统执行一个c++程序时所调用的函数，每个程序必须有且只有一个main函数
- 操作符（manipulator）对象，如：std::endl，在读写流的时候用来“操作”流本身。
- 成员函数（member function）类定义的操作，通常通过调用成员函数来操作特定对象。
- 方法（method）成员函数的同意属于。
- 命名空间（namespace）将库的名字放在一个单一位置的机制，命名空间可以帮助避免不经意的名字冲突。C++标准库定义的名字在命名空间std中
- ostream标准库类型，提供面向流的输出。
- 形参列表（parameter list）函数定义的一部分，指出调用函数时可以使用什么样的实参，可能为空列表
- 返回类型（return type）函数返回值的类型
- 标准输出（standard output）输出流，通常与程序执行所在查看相关联
- 字符串常量（string literal）零或多个字符组成的序列，用双引号包围（“a  string literal“）;
- 初始化变量（uninitialized variable）为赋予初值的变量，类类型的变量如果为指定初值，则按类定义指定的方式进行初始化。定义在函数内部的内置类型变量默认是不初始化的。除非有显式的初始化语句，试图使用一个未初始化的值是错误的，未初始化变量是bug的常见成因。
- 变量（variable）具名对象
- while语句（while statement）迭代语句，提供重复执行直至特定条件为假的机制。循环体会执行零次或多次，依赖于循环条件求值结果。
- （）运算符（（）operator）调用运算符，跟随在函数名之后的一对括号“（）”起到调用函数的效果，传递给函数的实参放置在括号内。
- ++运算符（++operator）递增运算符，将运算对象的值加1，++i等价于i = i + 1；。
- +=运算符（+= operator）符合赋值运算符，将右侧运算对象加到左侧运算对象上； a+=b；等价于a = a +b;
- .运算符（.operator)点运算符。左侧运算对象必须是一个类型对象，右侧运算符对象的一个成员名字，运算结果即为该对象的这个成员。
- ：：运算符（：：operator）作用域运算符，其用处之一是访问命名空间中的名字，例如std::cout表示命名空间std中的名字cout。
- =运算符（=operator）将右侧运算符对象值赋予左侧运算对象所表示的对象。
- --运算符（--operator)递减运算符。将运算对象的值减1，--i等价于i = i -1；
- <<运算符（<<operator）输出运算符将，右侧运算对象的值写到左侧运算对象表示的输出流：cout<<"hi"表示将hi写到标准输出。输出运算符可以连接:cout<<"hi"<<"bye"表示将输出hibue。
- 》》运算符（>>operator）输入运算符，从左侧运算对象所指定的输入流读取数据，存入右侧运算对象中，cin>>i表示从标准输入读取一个值，存入i中，输入运算符可以连接：cin>>i>>j表示一个存入i，再读取一个值存入j
- ==运算符（==operator）相等运算符，检测左侧运算对象是否等价于右侧运算符。
- ！= 运算符（！= operator）不等运算符，检测左边运算对象是否不等于右侧对象。
- 《=运算符（<=operator）小于等于运算符，检测左边运算对象是否大于右侧运算对象
- 《运算符（<operator）小于运算符，检测左边运算对象是否小于右侧运算对象。
- 》=运算符（>=operator）大于等于运算符。检测左侧运算对象是否大于等于右侧运算对象。
- 》运算符（>operator）大于运算符。检测左侧运算符对象是否大于右侧运算对象。

## 第二章、变量和基本类型

### 2.1基本内置类型

### 2.1.1算术类型



## 第三章、

### 3.5

####  3.5.4、练习

- 3.7
  - 指针相关的属性有三个
    ​	指针本身的值 --是一个内存地址，表示指针所指对象在内存中的存储地址，
    ​	指针所指的对象——可以通过解引用指针访问，因为指针也是一个对象，
    ​	指针本身在内存中存储的位置——所以指针也存储在内存的某个位置，它有自己的地址，这也是为什么有“指针的指针”的原因
    ​	 相加——把内存中两个对象的内存地址加在一起
    ​	 相减——如果两个指针指向同一组数据中的两个不同元素，则他们相减的结果表明了他们所指的元素在数组中的距离

#### 3.5.5与旧代码的接口

- 允许使用以空字符结束的字符串数组来初始化string对象或为string对象赋值。
- 在string对象的加法运算中允许使用以空字符串结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值中允许使用以空字符结束的字符串作为右侧的运算对象

- 如果执行完C_str()函数以后程序向一直使用其返回的数组，最好将该数组重新拷贝一份
- 建议：
  - 使用指针和数组很容易出错，一部分原因是概念上的问题，指针常用于底层操作，因此容易引发一些与烦琐细节有关的错误，其他问题则源于语法错误，特别是声明指针时的语法错误。
  - 现代的C++程序应该尽量使用vector和迭代器，避免使用内置数组和指针，应该尽量使用string，避免使用c风格的基于数组的字符串。

### 3.6多维数组

- 严格来说C++没有多维数组，多维数组其实是数组的数组

## 第四章、表达式

### 4.1基础

#### 4.1.1

- 重载运算符——当运算符作用域类类型的运算对象时，用户可以自动定义其含义，因为这种自动以过程事实上是为了以存在的运算符赋予了另一外一层含义，所以称之为重载运算符
- 左值可以位于赋值语句左侧，右值则不能
- 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被作用域左值的时候，用的是对象的身份（在内存中的位置）
- 在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用，当一个左值被当成右值使用时，实际使用的是它的内容（值）
- 赋值运算符需要应该和（非常量）左值作为其左侧运算对象，得到的结果也任然是一个左值
- 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个又值。
- 内置解引用运算符，下标运算符、迭代器解引用运算符，string和vector的下标运算符，的求值结果左值。
- 内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值



#### 4.5

- 前置版本首先将运算对象加1或减1，然后把改变后的对象作为求值结果，
- 后置版本也是讲运算对象加1或减1，但是求值结果是运算对象改变之钱那个值的副本，
- 这两种运算符必须作用于左值运算对象
- 前置版本将对象本身作为左值返回
- 后置版本则将对象原始值的副本作为右值返回
- 如果一条表达式中出现了递增运算符，则其计算规律是：++在前，先加1在计算，++在后先运算在加1

#### 4.6

- 箭头运算符作用于一个指针类型的运算对象，结果是一个右值，点运算符分成梁总情况
- 如果成员所属的对象是左值，那么结果是左值
- 如果成员所属的对象是右值，那么结果是右值
- 

#### 4.9、sizeof

- 对char或者类型为char的表达式执行sizeof运算，结果的1
- 对引用类型执行sizeof运算得到被引用对象占空间的大小
- 对指针执行sizeof运算得到指针本身所占空间的大小
- 对解引用执行sizeof运算得到指针所指向的对象所占空间的大小，指针不需要有效
- 对数组执行sizeof运算得到整个数组所占空间的大小，等价于数组中所有的元素个执行一次sizeof运算并将得到结果求和，注意，sizeof运算不能把数组转换成指针来处理
- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的所占用了多少空间。
- 

#### 4.11、类型转换

自动转换的情况

- 在大多数表达式中，比int类型小的整型值首先提升为较大的整型类型
- 在条件中，非布尔值转换成布尔类型
- 初始化过程中，初始值转换成为变量的类型：在赋值语句中，右侧运算对象转换成左侧运算对象的类型
- 如果算术运算符或关系运算符的运算对象有多种类型，需要转换成同一种类型
- 函数调用时也会发生类型转换
- 

## 第五章、语句

### 5.1条件语句

- 空语句由一个单独的分号构成，如果在程序的某个地方，语句上需要一条语句但是逻辑上不要，此时应该使用空语句，空语句什么也不做
  循环的时候会用到，空语句最好添加注释
- 块是指用花括号括起来的语句和声明的序列，也称为符合语句
  一个快就是一个作用域，在快中引入的名字只能在块内部以及嵌套在块中的字块里面访问，如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，此时应该使用块，

#### 什么是悬垂else

悬垂else是指当程序中的if分支多余else分支时，如何为else寻找于之匹配的if分支问题

C++规定，else与离它最近的尚未匹配的if匹配，从而消除了二义性




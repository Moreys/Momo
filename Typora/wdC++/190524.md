# 20190524笔记
-------
昨天内容内容
## 1、继承
### 1.1、不能被继承的
- 

### 1.2、派生类内部和派生对象对基类成员的访问权限
- 派生类对象只能访问public继承的public成员，其他的一律不能进行访问
- 派生类内部，不管以哪种方式继承，都不能直接访问基类的私有成员
- 派生类内部部，不管以何种方式继承，都可以直接访问基类的非私有成员
  - 采用public 继承，基类的非私有成员在派生类内部访问权限不变
  - protected 
- protected继承与private继承的差别是
  - 当出现更多层次继承体系时，如果采用protected继承，不管继承层次有多少层，在培生类体系汇总都能访问顶层基类的成员
  - 当继承体系中出现一侧private继承后，就会被打断，此后在派生时不能再访问顶层基类的成员

### 1.2、多层继承   多基派生
- 默认继承权限是私有的
- 成员名访问冲突的二义性
  - 通过：类名::函数解决------->作用域限定符解决
- 菱形继承
  - 存储二义性问题，有共同的顶层基类，第二层有来两个类都继承顶层基类，第三层一个类继承第二层的两个类
  - 解决：采用虚拟继承

### 1.3、派生类的创建
- 总原则：先构造基类部分，再构造派生类部分
- 1、派生类没有显示定义构造函数时----->基类必须提供一个默认构造函数

- 2、当派生类有显示定义构造函数的时候，------> 在调用派生类构造函数时，必须要将基类构造放在初始化派生类构造函数初始化列表中。
- 错误说法：
- 正确说法：创建派生对象时，调用的就是派生类的构造函数，在执行派生类初始化表达式时，调用了基类的构造函数。进而完成初始化过程。
- const/引用成员/子对象成员，都需要放在初始化表达式列表中进行初始化
### 1.4、派生类的析构
- 和构造是一个相反的过程
- 销毁派生类对象时，会自动调用派生类的析构函数，再自动调用基类的析构函数。

### 1.5、基类与派生类之间的转化
- 类型适应的概念：派生类适应基类，----->功能多的能替换功能少的
- 向上转型  ------> 反过来都是不行的。会操作一部分不属于基类的内存空间，所有可能存在问题
  - 可以把一个派生类对象，赋值给基类对象
  - 可以把基类指针，指向一个派生类对象   反过来不行
  - 可以把一个基类引用绑定到派生类对象   
- 向下转型
  - 成功条件------>转换过去时操作的确实是一个派生类对象
### 1.5、派生类对象的赋值空间
1. 基类也有显示定义复制控制函数，派生没有，在执行派生类对象间的赋值控制时，会自动调用基类的复制控制函数
2. 基类有显式复制控制函数，派生类页游显式定义的复制控制函数，在执行派生对象间的复制控制时，必须要显示调用基类的复制控制函数


### 1.6、三个概念的解释
- 重载：类内部有同名函数，参数不同（类型、顺序、个数）
- 隐藏：父子类，函数名称相同
- 覆盖：父子类， 同名虚函数  参数要完全相同
## 2、多态
### 2.1、静态多态------>编译时
- 函数重载， 运算符重载
### 2.2、动态多态------> 运行时
- 虚函数的实现原理
  - 虚表 ---->  
    - 虚函数指针 
  - 如何激活动态多态 
    - 基类定义虚函数
    - 派生类覆盖虚函数
    - 创建派生类对象
    - 基类指针或者引用指向派生类对象
    - 基类指针或者引用调用虚函数


----------------------
- 通过对象名调用虚函数时，不会展现多态机制，隐藏通过

## 3、虚函数的调用情况

### 3.2 、在类的成员内部使用
- 
- 
## 4、多态   -----> 一种调用语句有多种表现形态
### 4.1、 类型兼容性原则遇上函数重写
- 需求：
  - 
- 父类创建一个对象以后，我想让他执行


# 20190529笔记
## 1、复习昨天内容
### 1.1、函数模板 ====>模板函数
- 泛型编程 ----->类型参数化
- template <typename /class T1,...>
- 在实际调用的时候，进行模板参数推导----->代码生成器
- 显示实例化，隐式实例化
- 模板参数有两类
  - 类型参数
  - 非类型参数，常量表达式，整型数据（bool/char/short/int/long)
    - 提供了一种新的方式设置常量
  - 模板的特化版本，针对于某一个具体的类型进行实现
  - 对于普通类中的某一个函数，也可以定义成模板，成员函数模板

- 可变模板参数
  - template<typename ...Args>  模板参数包//声明时... 在左边
  - void func(Args... args) 函数参数包，声明时  ...在左边
  - func(args...) 实际在使用时， ...要放在右边   此时是进行参数的拆包(解包) 
  - 如果是递归调用时，需要给一个函数的出口。

### 1.2、类模板 -----> 模板类
- 对于成员函数，如果在类之外实现时，都必须要加上template<....> 
- Class <T> 

## 2、STL(Standard Template Library)标准模板库
- 本质是数据结构和算法
### 2.1六大组件
#### 1、容器
- 线性容器
  - array 
  - vector  
    - 三个指针的可变数组
    - begin()开始位置 [   ) 左闭右开的区间
    - end()最后一个元素的下一个位置 
    - end_of_storag
    - 为什么不提供头部操作
      - 头部插入要移动元素，时间复杂度O(n)
    - list    双向循环链表
    - forward_list
    - deque  双端数组、双端队列、双向队列
        - 元素在N个片段内部，片段内连续，片段之间不连续，有一个头有一个尾指针指向里面的元素----->通过中控器来进行所有的片段管理---->迭代器、first/last/cur/node

      - 构造函数
        - 无参构造
--------
- **关联容器**
  - set  中默认情况下按升序的方式进行排列
    - 底层是红黑树。只有Key的方式进行排列，以为是排列的，所有修改以后回破坏排序，所有不支持修改。------>近视平衡二叉树，访问某一个节点的时间复杂度为NlogN。
    - 红黑树-----》节点不红则黑，根节点为黑，所有叶子节点是黑色，不能有两个连续红色的节点，从根节点到任意一个叶子节点的路径之上的黑色节点的个数相同。
    - set中不能存放关键字相同的元素----->只有key的概念 只读不能修改---->更多的是查找操作
    - 不能使用下标访问-----双向迭代器访问
    - 也有insert操作---> 要判断返回是否插入成功。
    - 不能修改已经添加到其中的元素。是只读的。
  - 针对于自定义类类型都要重载其比较方式，默认情况下重载小于符号；也可以给出自定义函数对象

  - **map**
    - 构造函数的形式  
    - 默认情况下，采用升序方式进行排列
    - 不能够存放关键字相同的元素 ------>键值对. ---->关键字不能修改，关键字对应的值可以修改.
    - 下标访问----
      - 元素存在时，通过key直接拿到相应 的value
      - 元素不存在时，会通过key添加一个元素，但是对应的value的默认值
      - 元素存在时可以通过它直接修改value的值。
      - key无法修改
      - 因为底层是红黑树，所有查找时间复杂度还是为O(LogN);只是在显示上面给人一种O(1)的感觉
      - 查找元素 find  count
        -  
---------    
- 无序容器
  - 采用hash  (散列) ---->容量只有一半的空间能利用上
  - 
#### 2、迭代器
  - 适配器
  - 算法

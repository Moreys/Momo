# 190522笔记
## 1、复习前面知识
- 运算符重载
### 1.1类中类
- PIMPL设计
  - 隐藏信息
    - 只要头文件不变接口可以不变  实现可以随便改变
    - 
### 1.2、单例对象的自动释放  --->析构函数会自动调用
- 内存泄漏检测工具没有那么智能
- 方式一
  - 嵌套类 + 静态对象
  - 在类中定义另一个类 直接拿到_pInstance对象
  - 对象需要在类之外定义 
- 方式二  atexit + 静态方法
  - atexit注册的函数指针，在函数退出时，会自动调用
  - 如果使用懒汉模式会存在------>在多线程环境下是不安全的
  - 可以加锁解决，也可以添加线程锁 ------>问题：如果提示创建对象了一直没有用也会存在问题。
- 方式三  atexit + pthread_once 
  - 针对linux环境下进行，因为使用到了POSIX标准
  - 能够保证在多线程环境下，init函数只会被执行一次
  - 存在平台先关性------> 问题：POSIX·标准下才能使用线程库
### 1.3、写时复制 (面试精华)
- string的底层复制  深拷贝  COW  fbstring
- COW   
  - 并不是直接执行深拷贝
  - 如果复制操作只是进行读取，则直接执行深拷贝会有浪费，时间复杂度是O(n)的
  - COW的实现采用的是深拷贝，再多加一个引用计数
  - 当执行赋值或者复制构造时，只需要将引用计数加1就可以了，时间复杂度为O(1)
  - 当字符串对象销毁时，只需要将引用计数减1，当引用计数为写，才真正释放申请的空间
  - 如果字符串对象是共享同一个空间的数据，其中一个需要修改，才真正去执行深拷贝
  - 读写引用计数太频繁，有可能会有非线程安全问题，所有实现中一般会采用原子操作。————也有可能会有消耗问题
  - 采用代理模式进行监控读时的操作。





## 2、发布一个产品
- 源码  开源产品
- 头文件 + 库的形式  静态库 + 动态库（更多） 达到信息隐藏
  - 达到信息隐藏
  - 头文件不变  实现我可以随便改造  实现一个库的平滑升级




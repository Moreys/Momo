## 190516笔记
## 重载new和delete
- 还是看成一个函数来进行处理，只不过加上对申请空间的限制而已
- 

## 2、new/delete工作机制
- new发送的三个步骤
  - 调用名为operator new的标准库函数，分配足够大的原始尚未类型化的内存，以保存指定类型的一个对象
  - 运行该类型的一个钩子函数取初始化对象
  - 返回指向新分配并构造函数对象的指针
- 使用delete时，
  - 调用析构函数
  - 调用名为operator delete的标准库函数释放对象所用的内存
- 重载的时候有两个版本 因为使用本身就有两个版本
  - 是否带[]是有区别的，如果没有带那就是特指一个对象，如果带了就指[]里面所有的对象

## 只能生成栈对象或者只能生成堆对象
- 只能生成栈对象
  - 即不能通过new表达式[在类之外]生成对象
  - 方法
    - operator new 函数 放入到private区域

- 只能生成堆对象
  - 在创建堆对象时，不能[在类之外]调用构造函数或者析构函数
  - 方法
    - 将构造函数放到private区域
    - 将析构函数放到private区域
    - 对于堆对象而言，执行delete表达式无法通过编译
    - 在public区域定义一个destroy()

## 4、输入输出
- 标准输入输出I/O 键盘输入和屏幕输出
- 文件I/O ，就是从磁盘文件进行读取和输入等
- 串I/O 字符串输入输出，对内存中指定的空间进行输入输出

### 4.1、流的概念
- 看成水管
- 输入流：从程序外部输入数据到程序里面
- 输出流：从程序内部输出数据到外部（磁盘文件等）
- 输入输出的参照物是程序
- 头文件为<iostream>
- 流的分类
  - 标准输入输出流  ——头文件<iostream>   cin/cout/cerr
  - 文件输入输出流  —— 头文件<fstream> ifstream/ofstream/fsstream---->类
  - 字符串流-----> 头文件<sstream> istringstream/ostringstream/stringstream----->类
- 标准输出流
  - cout不是关键字而是ostream流类的对象
  - 使用的时候系统自动判定类型，根据类型选择运算符重载函数
  - cout流在内存中开辟了缓冲区，插入endl时，不管什么结果都立即输出流中所有数据，然后插入一个换行符，刷新流，清空缓冲区
- 标准输出流
 - cin 通常跳过输入流中的空格，tab，换行等空白字符
 - 只有输入完毕按回车以后，才行数据才被送入键盘缓冲区，形成输入流

- 字符串流成员函数
  - 用get函数读取字符，三种形式，无参数，有一个参数，有3个参数的。
  - 不带参数的调用方式：cin.get() 返回读到的那个字符 结尾返回EOF
  - 有一个参数符get函数
    - cin.get(ch) 读取一个字符，赋给字符变量ch，成功返回非0，失败返回0
  - getline读取一行
    - getline(char*, int n, char delim) 

-------
- 流的状态
  - badbit 系统级故障，不可恢复
  - faibit 可以恢复的错误
  - eofbit 就碰到了文件结尾
  - goodbit  有效状态
- 查询流的状态
  - cin.bad()
  - cin.fail()
  - cin.eof()
  - cin.good()
- 重置流的状态    cin.clear()
- 清空缓冲区  cin.ignore(1024,'\n')

- 文件流的使用
  - 必须定义一个文件流类的对象，通过文件流对象将数据从内存输出到磁盘文件，或者通过文件流从磁盘将文件输入到内存
  - 相关操作
    - ios::in 打开文件读操作
    - ios::out 打开文件写操作 会删除原有数据
    - ios::app 每次写之前找到文件尾
    - ios::trunc 打开文件时情况以及存在的文件流
    - ios:ate 打开文件后立即定位到文件末尾
    - ios::binary 二进制博士进行io操作

-------
- 字符串流
  - 和文件流不同的是
    - 数据对象为内存中的空间，而不是外存，对象是内存
    - 关联对象不是文件，而是内存中的一个存储空间 不需要要打开和关闭文件
    - 使用场景
      - 数值与字符串相互转化
      - 格式化输出或获取数据
